#python #Конспект #Программирование #web #django #linux 

HttpRequest хранит данные о запросе и опрееляет ряд атрибутов:

- scheme: схема запроса (http или https)
    
- body: представляет тело запроса в виде строки байтов
    
- path: представляет путь запроса
    
- method: метод запроса (GET, POST, PUT и т.д.)
    
- encoding: кодировка
    
- content_type: тип содержимого запроса (значение заголовка CONTENT_TYPE)
    
- GET: объект в виде словаря, который содержит параметры запроса GET
    
- POST: объект в виде словаря, который содержит параметры запроса POST
    
- COOKIES: отправленные клиентом куки
    
- FILES: отправленные клиентом файлы
    
- META: хранит все доступные заголовки http в виде словаря. Набор заголовков зависит от клиента и сервера, некоторые из них:
    
    - `CONTENT_LENGTH`: длина содержимого.
    - `CONTENT_TYPE`: MIME-тип запроса.
    - `HTTP_ACCEPT`: типы ответа, которые принимает клиент.
    - `HTTP_ACCEPT_ENCODING`: кодировка, в которой клиент принимает ответ.
    - `HTTP_ACCEPT_LANGUAGE`: язык ответа, который принимает клиент.
    - `HTTP_HOST`: хост сервера.
    - `HTTP_REFERER`: страница, с которой клиент отправил запрос (при ее наличии).
    - `HTTP_USER_AGENT`: юзер-агент или информация о браузере клиента.
    - `QUERY_STRING`: строка запроса.
    - `REMOTE_ADDR`: IP-адрес клиента.
    - `REMOTE_HOST`: имя хоста клиента.
    - `REMOTE_USER`: аутентификационные данные клиента (при наличии)
    - `REQUEST_METHOD`: тип запроса (GET, POST).
    - `SERVER_NAME`: имя хоста сервера.
    - `SERVER_PORT`: порт сервера.
- headers: заголовки запроса в виде словаря
    

**Также HttpRequest определяет ряд методов. Отметим следующие из них:**

- get_full_path(): возвращает полный путь запроса, включая строку запроса
    
- get_host(): возвращает хост клиента, для этого используется значения заголовков `HTTP_X_FORWARDED_HOST` (если включена опция USE_X_FORWARDED_HOST) и `HTTP_HOST`
    
- get_port(): возвращает номер порта

Пример. Получим даные о запрое. Для этого в **views.py** напишем:
```python
from django.http import HttpResponse
 
def hw(request):
    host = request.META["HTTP_HOST"] # получаем адрес сервера
    user_agent = request.META["HTTP_USER_AGENT"]    # получаем данные бразера
    path = request.path     # получаем запрошенный путь
     
    return HttpResponse(f"""
        <p>Host: {host}</p>
        <p>Path: {path}</p>
        <p>User-agent: {user_agent}</p>
    """)
```

А в **urls.py** напишем:
```python
from django.urls import path
from 1 import views
 
urlpatterns = [
    path("index", views.hw),
]
```

В данном случае получаем два заголовка "HTTP_HOST" и "HTTP_USER_AGENT" и запрошенный путь.

Результат следующий:
==Host: 127.0.0.1:8000==
==Path: /==
==User-agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 YaBrowser/24.6.0.0 Safari/537.36==

# HttpRequest - отправка ответа
Рассмотренная функциональность не ограничивается тем, что мы изучили. Это вообще очень интересный экземпляр и имеет такие параметры.

```python
HttpResponse.__init__(content=b'', content_type=None, status=200, reason=None, charset=None, headers=None)
```

Параметры:

- **content**: содержимое ответа в виде строки байтов. Если передается другое содержимое, то оно конвертируется в строку байтов
    
- **content_type**: MIME-тип ответа, устанавливает HTTP-заголовок `Content-Type`. Если этот параметр не установлен, то применяется mime-тип `text/html` и значение настройки DEFAULT_CHARSET, то есть в итоге будет: `"text/html; charset=utf-8"`.
    
- **charset**: кодировка ответа в виде строки. По умолчанию django пытается установить кодировку из параметра content_type, а в случае неудачи для установки кодировки применяется настройка `DEFAULT_CHARSET`.
    
- **status**: статусный код ответа. По умолчанию равно 200
    
- **reason_phrase**: сообщение, которое отправляется в вместе статусным кодом
    
- **headers**: заголовки ответа в виде словаря
    

Для хранения отправляемых данных он определяет ряд атрибутов. Некоторые из них:

- **content**: содержимое ответа в виде строки байтов
    
- **headers**: отправляемые заголовки в виде словаря
    
- **charset**: кодировка ответа в виде строки. По умолчанию django пытается установить кодировку из заголовка content_type, а в случае неудачи для установки кодировки применяется настройка `DEFAULT_CHARSET`.
    
- **status_code**: статусный код ответа
    
- **reason_phrase**: сообщение, которое отправляется в вместе статусным кодом

Рассмотрим некоторые возможности. Например, изменим определение функции в файле views.py:

```python
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Hello METANIT.COM", headers={"SecretCode": "21234567"})
```
В данном случае также устанавливается заголовок "SecretCode". Хотя в реальности в HTTP не существует такого заголовка, но мы можем определять кастомные заголовки, чтобы передать через них клиенту какую-нибудь информацию. Например, после обращения к функции мы можем в браузере через инструменты разработчика проинспектировать отправленные сервером заголовки и найти там в том числе заголовок "SecretCode".

Подобным образом можно установить другие параметры, например, статусный код и сообщение к нему:

```python
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("Произошла ошибка", status=400, reason="Incorrect data")
```
Так можно выдать ошибку и присвоить ей код.

Установка содержимого и кодировки:
```python
from django.http import HttpResponse
 
def index(request):
    return HttpResponse("<h1>Hello</h1>", content_type="text/plain", charset="utf-8")
```
Таким образом, из-за "text/plain" будет выводиться именно то, что мы ввели, не изменяясь в код.
