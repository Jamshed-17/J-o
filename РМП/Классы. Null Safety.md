## Классы

Классы декларируются ключевым словом `class`:

```kotlin
class Person { /*...*/ }
```

### Конструкторы

В Kotlin классы имеют первичный конструктор и один или несколько вторичных.

#### Первичный конструктор

Первичный конструктор объявляется в заголовке класса, идёт после имени класса и его параметров. Контент, содержащийся внутри `()` называется заголовок класса.

Если первичный конструктор не имеет аннотаций или модификаторов видимости, ключевое слово `constructor` может быть не использовано.

```kotlin
class Person constructor(firstName: String) { /*...*/ }
class Person(firstName: String) { /*...*/ }
```

Заголовок класса не может содержать любой исполняемый код. Если вы хотите запускать код во время создания объекта, используйте блоки инициализации внутри тела класса.

#### Блоки инициализации

Блоки инициализации объявляются ключевым словом `init` и последующими фигурными скобками.

```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints $name")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}
```

Во время инициализации экземпляра, блоки инициализации выполняются в том же порядке, как они объявлены в теле класса, чередуясь с инициализаторами свойств.

Параметры первичного конструктора могут быть использованы в блоке инициализатора. Они могут быть использованы в инициализаторах свойств, объявленных в теле класса.

Рекомендуется объявлять свойства как переменные только для чтения (`val`), если в будущем не потребуется изменять их состояние после объявления класса.

Kotlin имеет краткий синтаксис для декларации свойств и инициализации их из первичного конструктора:

```kotlin
class Customer(name: String) {
    val customerKey = name.uppercase()
}

class Person(val firstName: String, val lastName: String, var age: Int)
```

#### Вторичные конструкторы

Класс может содержать вторичные конструкторы с префиксом `constructor`.

Если класс имеет первичный конструктор, каждый вторичный конструктор должен быть делегирован первичному конструктору, первично или косвенно через другой вторичный конструктор(ы).

Делегирование другому конструктору того же класса выполняется с использованием ключевого слова `this`.

```kotlin
class Person(val name: String) {
    val children: MutableList<Person> = mutableListOf()
    
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
```

### Создание экземпляра класса

Для создания экземпляра класса используется следующий синтаксис:

```kotlin
class Person(val firstName: String, val lastName: String, var isEmployed: Boolean = true)
class Person(val pets: MutableList<Pet> = mutableListOf())

class Pet {
    constructor(owner: Person) {
        owner.pets.add(this)
    }
}
```

### Доступ к свойствам и методам класса

В дополнение к объявлению свойств как части характеристик объекта, можно установить поведение объекта с функциями-членами.

В Kotlin функции-члены должны быть заданы внутри тела класса. Для того чтобы обратиться к функции-члену, пишется название функции после имени экземпляра через точку:

```kotlin
class Contact(val id: Int, var email: String) {
    fun printId() {
        println(id)
    }
}

fun main() {
    val contact = Contact(1, "test")
    contact.printId() // 1
}
```

## Data classes

Классы данных в Kotlin в основном используются для хранения данных. Для каждого класса данных компилятор автоматически генерирует дополнительные функции-члены, которые позволяют вам выводить экземпляр в читаемый вывод, сравнивать экземпляры, копировать экземпляры и т.д.

Классы данных помечены ключевым словом `data`:

```kotlin
data class User(val name: String, val age: Int)
```

Одни из самых полезных функций-членов в классах данных:

1. `.toString()` - Выводит читаемую строку экземпляра класса и их свойств.
2. `.equals()` или `==` - Сравнивает экземпляры класса.
3. `.copy()` - Создает экземпляр класса, копирующий другой, возможно с несколько измененными свойствами.

Чтобы обеспечить согласованность и осмысленное поведение сгенерированного кода, классы данных должны соответствовать следующим требованиям:

- Основной конструктор должен иметь хотя бы один параметр.
- Все основные параметры конструктора должны быть отмечены как `val` или `var`.
- Классы данных не могут быть абстрактными, открытыми, закрытыми или внутренними.

## Null Safety

В Kotlin возможны значения `null`. Для того чтобы избежать возможных проблем с значениями `null` в программе, в Kotlin встроена "null безопасность".

Null safety замечает возможные проблемы с `null` значениями во время компиляции, а не во время работы программы.

Null safety – комбинация особенностей, которая позволяет:

4. Явно показывать разрешенные `null` значения в программе.
5. Проверять на значения `null`.
6. Использовать безопасные вызовы свойств/функций, которые могут содержать значения `null`.
7. Предпринимать действия, если значения `null` были зафиксированы.

### Nullable-типы

Kotlin поддерживает Nullable-типы, которые дают возможность объявить о том, что тип может содержать значение `null`. Изначально, типам нельзя принимать значения `null`.

Nullable-тип можно объявить, явно используя знак вопроса (`?`) после объявления типа:

```kotlin
var a: String = "abc" // Non-nullable тип
a = null // Ошибка: Null can not be a value of a non-null type String

var b: String? = "abc" // Nullable тип
b = null // Успешно
```

### Проверка значений на Null

Можно проверять код на наличие значений `null` внутри условных выражений. Тут используется оператор безопасного вызова (safe call operator), который сперва проверяет значение на `null` и только потом получает доступ к свойству.

```kotlin
val b: String? = null
val l = if (b != null) b.length else -1
println(l) // -1
```

Безопасные вызовы могут быть сцеплены, если в свойствах объекта может содержаться значение `null`, тогда `null` будет возвращен без ошибки:

```kotlin
fun main() {
    var nullString: String? = null
    println(nullString?.uppercase()) // null
}
```

### Элвис-оператор

Можно задать стандартное значение, если было найдено значение `null`, используя элвис-оператор (`?:`) – вопросительный знак с двоеточием.

С левой стороны указывается, с чем сравнивается элвис-оператор, с правой стороны указывается, то значение, которое элвис-оператор будет возвращать в случае обнаружения `null` значения.

```kotlin
fun main() {
    var nullString: String? = null
    println(nullString?.length ?: 0) // 0
}
```




----



# Задания
1. Написать программу, создающую класс Person с полями name, age,
country. Создать метод класса для вывода данных пользователя

```kotlin
class Person(val name: String, val age: Int, val country: String){
    fun valuesPrint(){
        println("Hi! My name is ${name}, me ${age}, i from ${country}")
    }
}



fun main() {
    val Jamshed = Person("Jamshed", 18, "Zarychny")
    Jamshed.valuesPrint()
}
```

2. Создать массив из 3х пользователей.

```kotlin
class Person(val name: String, val age: Int, val country: String){
    fun valuesPrint(){
        println("Hi! My name is ${name}, me ${age}, i from ${country}")
    }
}



fun main() {
    
    val people = arrayOf(
        Person("Egor", 25, "USA"),
        Person("Denis", 30, "Canada"),
        Person("Jamshed", 22, "Zarychny"))
        
    for (i in people){
        i.valuesPrint()
    }
}
```


3. Написать программу, которая создаёт класс Rectangle со свойствами
width и height. Создать метод класса по вычислению площади
прямоугольника

```kotlin
class Rectangle(val width: Int, val height: Int){
    fun squareCalc(){
        val ret = width * height
        println("Площадь прямоугольника с высотой ${height} и шириной ${width} = ${ret}")
    }
}

fun main() {
	val square = Rectangle(20, 12)
    square.squareCalc()
}
```

4. Написать программу которая создаёт класс Circle со свойством radius.
Создать метод вычисляющий площадь окружности. Добавить метод
по выводу вычисленной площади окружности.

```kotlin
class Circle(val radius: Int){
    fun circleArea(){
        val ret = 3.14 * (radius * radius)
		println(ret)
    }
}

fun main() {
	val first = Circle(20) 
    first.circleArea()
}
```

