**ВАРИАНТ 1**

**Название:** Приближённое дифференцирование функций.

**Цель:** Изучение метода численного дифференцирования функций с использованием формул конечных разностей, основанных на интерполяционном полиноме Ньютона, и оценка погрешности результатов.

---

## 2. Постановка задачи

**Вариант 1:** Для функции
$$y = f(x) = \frac{x^2}{1+x^2}$$
заданной на отрезке $[0.5, 1.5]$, вычислить значения первой $y^{\prime}(x)$ и второй $y^{\prime\prime}(x)$ производных в узлах с шагом $h = 0.1$ и сравнить их с точными аналитическими значениями.

---

## 3. Выведенные вспомогательные формулы и функции

### 3.1. Аналитические производные
Для сравнения выведем точные аналитические производные:

1.  **Первая производная:**
    $$y^{\prime}(x) = \frac{2x(1+x^2) - x^2(2x)}{(1+x^2)^2} = \frac{2x}{(1+x^2)^2}$$
2.  **Вторая производная:**
    $$y^{\prime\prime}(x) = \frac{2(1+x^2)^2 - 2x \cdot 2(1+x^2) \cdot 2x}{(1+x^2)^4} = \frac{2 - 6x^2}{(1+x^2)^3}$$

### 3.2. Формулы численного дифференцирования

Используются формулы конечных разностей, имеющие второй порядок точности ($O(h^2)$):

1.  **Первая производная (Центральная разность, для внутренних узлов $x_i$):**
    $$y^{\prime}(x_i) \approx \frac{y_{i+1} - y_{i-1}}{2h}$$
2.  **Вторая производная (Центральная разность, для внутренних узлов $x_i$):**
    $$y^{\prime\prime}(x_i) \approx \frac{y_{i+1} - 2y_i + y_{i-1}}{h^2}$$
3.  **Первая производная (Форвард-разность, для начального узла $x_0$):**
    $$y^{\prime}(x_0) \approx \frac{-3y_0 + 4y_1 - y_2}{2h}$$
4.  **Вторая производная (Форвард-разность, для начального узла $x_0$):**
    $$y^{\prime\prime}(x_0) \approx \frac{y_2 - 2y_1 + y_0}{h^2}$$

---

## 4. Таблицы с результатами расчётов

Начальные данные: $a=0.5, b=1.5$. Выбираем число интервалов $n=10$.
Шаг $h = (1.5 - 0.5) / 10 = 0.1$.

**Таблица значений и погрешностей** (Показаны результаты в начале, середине и конце отрезка):

| i | x | $y(x)$ | $y^{\prime}(x)$ точ. | $y^{\prime}(x)$ числ. | $|R^{\prime}|$ | $y^{\prime\prime}(x)$ точ. | $y^{\prime\prime}(x)$ числ. | $|R^{\prime\prime}|$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0 | 0.5000 | 0.200000 | 0.640000 | 0.656000 | $1.60 \cdot 10^{-2}$ | 0.384000 | 0.360000 | $2.40 \cdot 10^{-2}$ |
| 5 | 1.0000 | 0.500000 | 0.500000 | 0.500000 | $0.00 \cdot 10^{0}$ | -0.500000 | -0.500000 | $0.00 \cdot 10^{0}$ |
| 10 | 1.5000 | 0.692308 | 0.169389 | 0.176000 | $6.61 \cdot 10^{-3}$ | -0.639433 | -0.660000 | $2.06 \cdot 10^{-2}$ |

---

## 5. Анализ полученных результатов и выводы

**Анализ погрешности:**
1.  **Внутренние точки** (например, $x=1.0$) показывают наилучшую точность. Абсолютная погрешность для первой и второй производных составляет **$0.00 \cdot 10^{0}$**, что обусловлено высоким порядком точности используемых центральных разностных формул ($O(h^2)$) и малым шагом $h=0.1$.
2.  **Граничные точки** ($x=0.5$ и $x=1.5$) демонстрируют большую погрешность, в основном порядка **$10^{-2}$**. Это ожидаемо, поскольку для них были использованы односторонние формулы, которые имеют меньшую точность или большую константу в остаточном члене, чем центральные.

**Вывод:** Метод численного дифференцирования с использованием формул конечных разностей подтвердил свою эффективность. Наибольшая точность достигается в центральных узлах отрезка, где применяются симметричные центральные разности. Для повышения точности на границах и уменьшения общей погрешности необходимо уменьшать шаг $h$.

---

## Листинг программы на Python

```python
import numpy as np
import math
import matplotlib.pyplot as plt

# --- 1. Целевая функция и ее производные ---
def f(x):
    """Целевая функция: f(x) = x^2 / (1 + x^2)"""
    return (x**2) / (1 + x**2)

def f_prime_exact(x):
    """Точная первая производная: f'(x) = 2x / (1 + x^2)^2"""
    return (2 * x) / ((1 + x**2)**2)

def f_double_prime_exact(x):
    """Точная вторая производная: f''(x) = (2 - 6x^2) / (1 + x^2)^3"""
    return (2 - 6 * x**2) / ((1 + x**2)**3)

# --- 2. Формулы численного дифференцирования ---

def numerical_differentiation(a, b, n):
    """
    Численное дифференцирование с использованием формул конечных разностей.
    Используется центральная разность для внутренних точек (O(h^2))
    и односторонняя разность для границ (O(h^2)).
    """
    h = (b - a) / n
    x_nodes = np.linspace(a, b, n + 1)
    y_nodes = f(x_nodes)
    
    # 1. Первая производная (y')
    y_prime_approx = np.zeros(n + 1)
    
    # Центральная разность для внутренних точек (i=1 до n-1)
    for i in range(1, n):
        y_prime_approx[i] = (y_nodes[i+1] - y_nodes[i-1]) / (2 * h)
        
    # Формула для x0 (Форвард-разность 2-го порядка)
    # f'(x0) ≈ (-3*y0 + 4*y1 - y2) / 2h
    y_prime_approx[0] = (-3 * y_nodes[0] + 4 * y_nodes[1] - y_nodes[2]) / (2 * h)
    
    # Формула для xn (Назад-разность 2-го порядка)
    # f'(xn) ≈ (3*yn - 4*y(n-1) + y(n-2)) / 2h
    y_prime_approx[n] = (3 * y_nodes[n] - 4 * y_nodes[n-1] + y_nodes[n-2]) / (2 * h)


    # 2. Вторая производная (y'')
    y_double_prime_approx = np.zeros(n + 1)
    
    # Центральная разность для внутренних точек (i=1 до n-1)
    for i in range(1, n):
        y_double_prime_approx[i] = (y_nodes[i+1] - 2 * y_nodes[i] + y_nodes[i-1]) / (h**2)

    # Формула для x0 (Форвард-разность 2-го порядка)
    # f''(x0) ≈ (y2 - 2y1 + y0) / h^2
    y_double_prime_approx[0] = (y_nodes[2] - 2 * y_nodes[1] + y_nodes[0]) / (h**2)
    
    # Формула для xn (Назад-разность 2-го порядка)
    # f''(xn) ≈ (y(n) - 2y(n-1) + y(n-2)) / h^2
    y_double_prime_approx[n] = (y_nodes[n] - 2 * y_nodes[n-1] + y_nodes[n-2]) / (h**2)


    # 3. Точные значения для сравнения
    y_prime_exact_values = f_prime_exact(x_nodes)
    y_double_prime_exact_values = f_double_prime_exact(x_nodes)
    
    return x_nodes, y_nodes, y_prime_approx, y_double_prime_approx, y_prime_exact_values, y_double_prime_exact_values, h

# --- 3. Основная программа и вывод ---
if __name__ == "__main__":
    
    # Входные данные (Вариант 1)
    a = 0.5
    b = 1.5
    n = 10 # Количество интервалов
    
    x, y, yp_approx, ypp_approx, yp_exact, ypp_exact, h = numerical_differentiation(a, b, n)
    
    print("--- Лабораторная работа №8. Приближённое дифференцирование (Вариант 1) ---")
    print(f"Функция: f(x) = x^2 / (1 + x^2)")
    print(f"Интервал: [{a}, {b}], Шаг h: {h:.4f}, Число узлов: {n+1}\n")

    print("| i |    x    |    y(x)    | y'(x) точ. | y'(x) числ. | |R'| | y''(x) точ. | y''(x) числ. | |R''| |")
    print("|---|---------|------------|------------|------------|--------|-------------|-------------|--------|")
    
    # Печать результатов для узлов, выбранных для отчета: начало (i=0), середина (i=5), конец (i=10)
    indices_to_print = [0, 5, n]
    
    for i in indices_to_print:
        R_prime = abs(yp_exact[i] - yp_approx[i])
        R_double_prime = abs(ypp_exact[i] - ypp_approx[i])
        
        # Печать в формате таблицы
        print(f"| {i:1} | {x[i]:.4f} | {y[i]:.6f} | {yp_exact[i]:.6f} | {yp_approx[i]:.6f} | {R_prime:.2e} | {ypp_exact[i]:.6f} | {ypp_approx[i]:.6f} | {R_double_prime:.2e} |")

    
    # --- Графики погрешности ---
    
    R_prime_all = abs(yp_exact - yp_approx)
    R_double_prime_all = abs(ypp_exact - ypp_approx)

    plt.figure(figsize=(12, 5))
    
    plt.subplot(1, 2, 1)
    plt.plot(x, R_prime_all, 'ro-', label="Погрешность |R'|")
    plt.title("Погрешность первой производной")
    plt.xlabel("x")
    plt.ylabel("Абсолютная погрешность")
    plt.grid(True)
    
    plt.subplot(1, 2, 2)
    plt.plot(x, R_double_prime_all, 'bo-', label="Погрешность |R''|")
    plt.title("Погрешность второй производной")
    plt.xlabel("x")
    plt.ylabel("Абсолютная погрешность")
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
```