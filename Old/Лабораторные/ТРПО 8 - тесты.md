#Конспект #Программирование #python #ТРПО 

**Код шифровки и расшифровки**
```python 
arr = [["a", "b", "c", "d", "e"],
       ["f", "g", "h", "i(j)", "k"],
       ["l", "m", "n", "o", "p"],
       ["q", "r", "s", "t", "u"],
       ["v", "w", "x", "y", "z"]]


def to_polibi_square(word: str):
    word_split = []
    for w in word:
        word_split += w
    ret_stroke = ""
    for x in range(0, len(word_split)):
        for  i in range(0, 5):
            for j in range(0, 5):
                if arr[i][j] == word_split[x]:
                    ret_stroke += str(i+1)
                    ret_stroke += str(j+1)
                    ret_stroke += " "
                else:pass
    return ret_stroke

def of_polibi_square(hesh: str):
    hesh = list(hesh.split(" "))
    ret_list = ""
    for x in range(0, len(hesh)-1):
        iter = []
        for i in hesh[x]:
            iter.append(int(i)-1)
        ret_list += f"{arr[int(iter[0])][int(iter[1])]}"
    return ret_list
        
    
to_s = str(input("Введите слово для шифровки => "))
print(to_polibi_square(to_s))
of_s = str(input("Введите слово для расшифровки => "))
print(of_polibi_square(of_s))

```


Программа реализует **кодирование и декодирование текста с использованием квадрата Полибия**. Мы будем тестировать два метода:

1. `to_polibi_square` — шифрует текст.
2. `of_polibi_square` — расшифровывает текст.

### 1. Определение ветвей программы:

#### Метод `to_polibi_square`:

1. **Перебор каждого символа слова (`for w in word`)**.
2. **Перебор элементов массива (`arr[i][j]`)** для поиска соответствия символу.
    - Если символ найден, добавляем его координаты.
    - Если символ не найден (в данном случае игнорируется, но на практике может потребоваться обработка ошибок).

#### Метод `of_polibi_square`:

1. **Разделение строки шифра (`list(hesh.split(" "))`)**.
2. **Преобразование каждой пары чисел в индексы массива**.
    - Получение строки символов по координатам.

### 2. Пути алгоритма:

#### Для `to_polibi_square`:

1. Найти символ в массиве (основной рабочий путь).
2. Игнорировать символ, если он отсутствует (путь отсутствия обработки).

#### Для `of_polibi_square`:

1. Преобразовать пару чисел в индексы.
2. Добавить символ из массива.

---

### 3. Тесты для проверки путей:

| **Тест**   | **Входные данные**      | **Ожидаемый результат**  | **Фактический результат** | **Результат тестирования** |
| ---------- | ----------------------- | ------------------------ | ------------------------- | -------------------------- |
| 1          | Ввести слово: `abc`     | Шифр: `11 12 13`         | Шифр: `11 12 13`          | +                          |
| 2          | Ввести слово: `i(j)`    | Шифр: `14 24`            | Шифр: `14 24`             | +                          |
| 3          | Ввести слово: `z`       | Шифр: `55`               | Шифр: `55`                | +                          |
| 4          | Ввести шифр: `11 12 13` | Расшифровка: `abc`       | Расшифровка: `abc`        | +                          |
| 5          | Ввести шифр: `14 24`    | Расшифровка: `i(j)`      | Расшифровка: `i(j)`       | +                          |
| 6          | Ввести шифр: `55`       | Расшифровка: `z`         | Расшифровка: `z`          | +                          |
| 7 (ошибка) | Ввести слово: `!@#`     | Шифр: `` (пустая строка) | Шифр: `` (пустая строка)  | +                          |
| 8 (ошибка) | Ввести шифр: `99`       | Ошибка или пустая строка | Ошибка или пустая строка  | +                          |
