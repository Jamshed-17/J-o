
**1. В чем отличие правильных (сильных) сущностей от слабых?**

- **Сильная (независимая) сущность** (Правильная сущность) – существует сама по себе, для ее идентификации не требуется связь с другими сущностями. Ее уникальный идентификатор (первичный ключ) не включает в себя атрибуты другой сущности.
    
- **Слабая (зависимая) сущность** – не может быть однозначно идентифицирована без связи с другой сущностью-владельцем. Ее первичный ключ частично или полностью формируется из первичного ключа сильной сущности (называется внешним ключом).
    

**2. В каком случае участие сущности в связи будет полным, а в каком — частичным?**

- **Полное участие** (обязательное): **Каждый** экземпляр сущности обязан участвовать хотя бы в одном экземпляре данной связи. На диаграмме изображается **двойной линией**.
    
- **Частичное участие** (необязательное): **Не каждый** экземпляр сущности участвует в экземпляре данной связи. Некоторые экземпляры могут существовать вне этой связи. На диаграмме изображается **одинарной линией**.
    

**3. Как изображаются сущности и связи в нотации Чена?**

- **Сущности** изображаются **прямоугольниками**.
    
- **Связи** изображаются **ромбами**.
    
- **Атрибуты** изображаются **овалами**.
    
- Мощность связи (кардинальность) обозначается числами или символами (**1**, **N**, **M**) на линиях, соединяющих сущности со связями.
    
- Участие (полное/частичное) может обозначаться **минимальной** мощностью связи: `0` (частичное) или `1` (полное).
    

**4. Как изображаются сущности и связи в нотации Баркера (нотация IE, "вороны лапки")?**

- **Сущности** изображаются **прямоугольниками с закругленными углами**. Атрибуты перечисляются внутри прямоугольника. Первичный ключ помечается символом `#` или подчеркиванием.
    
- **Связи** изображаются **сплошными линиями** между сущностями.
    
- Мощность связи (кардинальность) обозначается специальными символами на концах линий:
    
    - `┃` (перпендикулярная черта) – "один и только один" (1).
        
    - `○` (кружок) – "ноль или один" (0..1).
        
    - `コ` (лапка ворона) – "много" (одна или более, 1..*).
        
    - Комбинации, например: `○─コ` означает "ноль, одна или более" (0..*).
        

**5. При переходе от ER-диаграмм к реляционным отношениям каким образом описывается связь типа «многие ко многим»?**

Связь типа «многие ко многим» (M:N) **не может быть напрямую отображена в двух таблицах**. Для ее представления создается **новая таблица-ассоциация** (связующая таблица, junction table).

Эта новая таблица:

- Содержит **внешние ключи**, которые ссылаются на **первичные ключи обеих** связанных сущностей.
    
- Комбинация этих внешних ключей, как правило, образует **составной первичный ключ** новой таблицы.
    
- Может содержать свои собственные **атрибуты**, описывающие характеристики самой связи (например, "ДатаНазначения" для связи "Студент-Курс").


6. **В среде ERwin постройте логическую модель БД, аналогичную представленной на рис. 6.4. Поработайте с представлением модели в нотации IDEF1X и IE**

![[Pasted image 20251105100423.png]]

**7. Дополните модель новыми сущностями — «Пользователь», «Группа пользователей», «Периферийное устройство». Для периферийных устройств определите категории (пример, сканер и т.п.). Определите необходимые связи между сущностями: пользователи работают за компьютерами, пользователи объединены в группы и т.д.**

![[Pasted image 20251105104447.png]]

**8. Перейдите к физической модели БД для выбранной СУБД, создайте и настройте представляемые напрямую «список пользователей, работающих за определенным компьютером», «список групп и входящих в них пользователей», «список групп и количество входящих в них пользователей».**

CREATE DATABASE college;

CREATE TABLE Помещение (
    Номер_помещения INT PRIMARY KEY IDENTITY(1,1),
    Название_помещения NVARCHAR(100) NOT NULL,
    Описание NVARCHAR(255)
);

CREATE TABLE ПО (
    Идентификатор_программы INT PRIMARY KEY IDENTITY(1,1),
    Название_программы NVARCHAR(100) NOT NULL
);

-- Таблица: Компьютер
CREATE TABLE Компьютер (
    Номер_компьютера INT PRIMARY KEY IDENTITY(1,1),
    Имя_компьютера NVARCHAR(50) NOT NULL,
    Номер_помещения INT,
    FOREIGN KEY (Номер_помещения) REFERENCES Помещение(Номер_помещения)
);

-- Таблица: Связь компьютеров и ПО
CREATE TABLE Компьютер_ПО (
    Номер_компьютера INT,
    Идентификатор_программы INT,
    PRIMARY KEY (Номер_компьютера, Идентификатор_программы),
    FOREIGN KEY (Номер_компьютера) REFERENCES Компьютер(Номер_компьютера),
    FOREIGN KEY (Идентификатор_программы) REFERENCES ПО(Идентификатор_программы)
);

-- Таблица: Псевдонимы компьютеров
CREATE TABLE Псевдонимы_компьютера (
    Номер_компьютера INT,
    Псевдоним NVARCHAR(50) NOT NULL,
    Комментарий NVARCHAR(255),
    PRIMARY KEY (Номер_компьютера, Псевдоним),
    FOREIGN KEY (Номер_компьютера) REFERENCES Компьютер(Номер_компьютера)
);

-- Таблица: Категории периферийных устройств
CREATE TABLE Категория_устройств (
    ID_категории INT PRIMARY KEY IDENTITY(1,1),
    Название_категории NVARCHAR(100) NOT NULL
);

-- Таблица: Периферийные устройства
CREATE TABLE Периферийное_устройство (
    ID_устройства INT PRIMARY KEY IDENTITY(1,1),
    Серийный_номер NVARCHAR(50) NOT NULL,
    Модель NVARCHAR(100) NOT NULL,
    Дата_приобретения DATE,
    ID_категории INT,
    FOREIGN KEY (ID_категории) REFERENCES Категория_устройств(ID_категории)
);

-- Таблица: Категории групп пользователей
CREATE TABLE Категория_групп (
    ID_категории INT PRIMARY KEY IDENTITY(1,1),
    Название_категории NVARCHAR(100) NOT NULL
);

-- Таблица: Пользователи
CREATE TABLE Пользователь (
    ID_пользователя INT PRIMARY KEY IDENTITY(1,1),
    ФИО NVARCHAR(100) NOT NULL,
    Должность NVARCHAR(100),
    Логин NVARCHAR(50) NOT NULL UNIQUE,
    Номер_компьютера INT,
    ID_группы INT,
    FOREIGN KEY (Номер_компьютера) REFERENCES Компьютер(Номер_компьютера),
    FOREIGN KEY (ID_группы) REFERENCES Категория_групп(ID_категории)
);

INSERT INTO Помещение (Название_помещения, Описание) VALUES 
('Компьютерный класс 1', 'Основной компьютерный класс'),
('Серверная', 'Помещение с серверным оборудованием'),
('Офис 101', 'Рабочий офис');

INSERT INTO Категория_устройств (Название_категории) VALUES 
('Принтеры'),
('Сканеры'),
('Мониторы'),
('Клавиатуры');

INSERT INTO Категория_групп (Название_категории) VALUES 
('Администраторы'),
('Пользователи'),
('Гости');

INSERT INTO ПО (Название_программы) VALUES 
('Microsoft Office'),
('Adobe Photoshop'),
('Visual Studio'),
('Google Chrome');

INSERT INTO Компьютер (Имя_компьютера, Номер_помещения) VALUES 
('PC-001', 1),
('PC-002', 1),
('SRV-001', 2),
('OFFICE-001', 3);

INSERT INTO Компьютер_ПО (Номер_компьютера, Идентификатор_программы) VALUES 
(1, 1), (1, 4),
(2, 1), (2, 3), (2, 4),
(3, 1), (3, 2);

INSERT INTO Псевдонимы_компьютера (Номер_компьютера, Псевдоним, Комментарий) VALUES 
(1, 'Главный ПК', 'Основной компьютер в классе'),
(2, 'Резервный', 'Запасной компьютер');

INSERT INTO Периферийное_устройство (Серийный_номер, Модель, Дата_приобретения, ID_категории) VALUES 
('SN123456', 'HP LaserJet Pro', '2023-01-15', 1),
('SN789012', 'Epson Perfection V19', '2023-02-20', 2),
('SN345678', 'Dell UltraSharp 27"', '2023-03-10', 3);

INSERT INTO Пользователь (ФИО, Должность, Логин, Номер_компьютера, ID_группы) VALUES 
('Иванов Иван Иванович', 'Системный администратор', 'i.ivanov', 3, 1),
('Петрова Мария Сергеевна', 'Программист', 'm.petrova', 2, 2),
('Сидоров Алексей Петрович', 'Менеджер', 'a.sidorov', 4, 2);

CREATE OR ALTER VIEW Список_пользователей_по_компьютерам AS
SELECT 
    k.Номер_компьютера,
    k.Имя_компьютера,
    p.Название_помещения,
    u.ФИО,
    u.Должность,
    u.Логин,
    kg.Название_категории AS Группа
FROM Компьютер k
LEFT JOIN Пользователь u ON k.Номер_компьютера = u.Номер_компьютера
LEFT JOIN Помещение p ON k.Номер_помещения = p.Номер_помещения
LEFT JOIN Категория_групп kg ON u.ID_группы = kg.ID_категории
WHERE u.ФИО IS NOT NULL;
GO

CREATE OR ALTER VIEW Список_групп_и_пользователей AS
SELECT 
    kg.ID_категории,
    kg.Название_категории AS Группа,
    u.ФИО,
    u.Должность,
    u.Логин,
    k.Имя_компьютера,
    p.Название_помещения
FROM Категория_групп kg
LEFT JOIN Пользователь u ON kg.ID_категории = u.ID_группы
LEFT JOIN Компьютер k ON u.Номер_компьютера = k.Номер_компьютера
LEFT JOIN Помещение p ON k.Номер_помещения = p.Номер_помещения;
GO

CREATE OR ALTER VIEW Статистика_групп_по_пользователям AS
SELECT 
    kg.ID_категории,
    kg.Название_категории AS Группа,
    COUNT(u.ID_пользователя) AS Количество_пользователей,
    STRING_AGG(ISNULL(u.ФИО, 'Нет пользователей'), ', ') AS Список_пользователей
FROM Категория_групп kg
LEFT JOIN Пользователь u ON kg.ID_категории = u.ID_группы
GROUP BY kg.ID_категории, kg.Название_категории;
GO

CREATE INDEX IX_Пользователь_ID_группы ON Пользователь(ID_группы);
CREATE INDEX IX_Пользователь_Номер_компьютера ON Пользователь(Номер_компьютера);
CREATE INDEX IX_Компьютер_Номер_помещения ON Компьютер(Номер_помещения);
GO


SELECT Список пользователей по компьютерам AS Информация;
SELECT * FROM Список_пользователей_по_компьютерам;

SELECT Список групп и пользователей (с сортировкой) AS Информация;
SELECT * FROM Список_групп_и_пользователей 
ORDER BY ID_категории, ФИО;

SELECT Статистика групп по пользователям AS Информация;
SELECT * FROM Статистика_групп_по_пользователям;
GO

CREATE OR ALTER PROCEDURE Получить_пользователей_по_компьютеру
    @Номер_компьютера INT
AS
BEGIN
    SELECT 
        u.ФИО,
        u.Должность,
        u.Логин,
        kg.Название_категории AS Группа,
        k.Имя_компьютера,
        p.Название_помещения
    FROM Пользователь u
    JOIN Компьютер k ON u.Номер_компьютера = k.Номер_компьютера
    JOIN Помещение p ON k.Номер_помещения = p.Номер_помещения
    JOIN Категория_групп kg ON u.ID_группы = kg.ID_категории
    WHERE u.Номер_компьютера = @Номер_компьютера;
END;
GO

EXEC Получить_пользователей_по_компьютеру @Номер_компьютера = 2;
GO

CREATE OR ALTER VIEW Отчет_по_загруженности_компьютеров AS
SELECT 
    k.Номер_компьютера,
    k.Имя_компьютера,
    p.Название_помещения,
    COUNT(DISTINCT u.ID_пользователя) AS Количество_пользователей,
    COUNT(DISTINCT kp.Идентификатор_программы) AS Количество_программ,
    STRING_AGG(ISNULL(u.ФИО, 'Свободен'), ', ') AS Пользователи
FROM Компьютер k
LEFT JOIN Помещение p ON k.Номер_помещения = p.Номер_помещения
LEFT JOIN Пользователь u ON k.Номер_компьютера = u.Номер_компьютера
LEFT JOIN Компьютер_ПО kp ON k.Номер_компьютера = kp.Номер_компьютера
GROUP BY k.Номер_компьютера, k.Имя_компьютера, p.Название_помещения;
GO

SELECT Отчет по загруженности компьютеров AS Информация;
SELECT * FROM Отчет_по_загруженности_компьютеров
ORDER BY Номер_компьютера;
GO

CREATE OR ALTER VIEW Компьютеры_с_ПО AS
SELECT 
    k.Номер_компьютера,
    k.Имя_компьютера,
    p.Название_помещения,
    po.Название_программы
FROM Компьютер k
JOIN Помещение p ON k.Номер_помещения = p.Номер_помещения
JOIN Компьютер_ПО kp ON k.Номер_компьютера = kp.Номер_компьютера
JOIN ПО po ON kp.Идентификатор_программы = po.Идентификатор_программы;

SELECT 
    name AS Имя_представления,
    create_date AS Дата_создания
FROM sys.views 
WHERE name IN (
    'Список_пользователей_по_компьютерам',
    'Список_групп_и_пользователей', 
    'Статистика_групп_по_пользователям',
    'Отчет_по_загруженности_компьютеров',
    'Компьютеры_с_ПО'
);

SELECT 'Список_пользователей_по_компьютерам' AS Представление;
SELECT * FROM Список_пользователей_по_компьютерам;

SELECT 'Список_групп_и_пользователей' AS Представление;
SELECT * FROM Список_групп_и_пользователей ORDER BY ID_категории, ФИО;

SELECT 'Статистика_групп_по_пользователям' AS Представление;
SELECT * FROM Статистика_групп_по_пользователям;

SELECT 'Отчет_по_загруженности_компьютеров' AS Представление;
SELECT * FROM Отчет_по_загруженности_компьютеров ORDER BY Номер_компьютера;

SELECT 'Компьютеры_с_ПО' AS Представление;
SELECT * FROM Компьютеры_с_ПО ORDER BY Номер_компьютера;

**9. **Выполните прямое проектирование: по созданной модели получите схему БД (можно использовать любую поддерживаемую СУБД).**

CREATE OR ALTER VIEW Компьютеры_для_обслуживания AS
SELECT 
    k.Номер_компьютера,
    k.Имя_компьютера,
    p.Название_помещения,
    
    CASE 
        WHEN COUNT(kp.Идентификатор_программы) = 0 THEN 'Требуется установка ПО'
        WHEN COUNT(kp.Идентификатор_программы) > 5 THEN 'Требуется оптимизация ПО'
        ELSE 'Нормальное состояние'
    END AS Статус_ПО,
    
    COUNT(kp.Идентификатор_программы) AS Количество_установленных_программ,

    CASE 
        WHEN COUNT(u.ID_пользователя) = 0 THEN 'Свободен'
        WHEN COUNT(u.ID_пользователя) = 1 THEN 'Один пользователь'
        ELSE 'Несколько пользователей'
    END AS Статус_использования,
    
    COUNT(u.ID_пользователя) AS Количество_закрепленных_пользователей,

    CASE 
        WHEN COUNT(kp.Идентификатор_программы) = 0 THEN 'ВЫСОКИЙ'
        WHEN COUNT(u.ID_пользователя) > 1 THEN 'СРЕДНИЙ' 
        WHEN COUNT(kp.Идентификатор_программы) > 5 THEN 'СРЕДНИЙ'
        ELSE 'НИЗКИЙ'
    END AS Приоритет_обслуживания,

    CASE 
        WHEN COUNT(kp.Идентификатор_программы) = 0 THEN 'Установить базовый пакет ПО'
        WHEN COUNT(kp.Идентификатор_программы) > 5 THEN 'Проверить на избыточность ПО'
        WHEN COUNT(u.ID_пользователя) > 1 THEN 'Рассмотреть разделение доступа'
        ELSE 'Плановый осмотр'
    END AS Рекомендуемое_действие,
    
    STRING_AGG(ISNULL(po.Название_программы, 'Нет ПО'), ', ') AS Список_ПО,
    STRING_AGG(ISNULL(u.ФИО, 'Нет пользователя'), ', ') AS Закрепленные_пользователи

FROM Компьютер k
LEFT JOIN Помещение p ON k.Номер_помещения = p.Номер_помещения
LEFT JOIN Компьютер_ПО kp ON k.Номер_компьютера = kp.Номер_компьютера
LEFT JOIN ПО po ON kp.Идентификатор_программы = po.Идентификатор_программы
LEFT JOIN Пользователь u ON k.Номер_компьютера = u.Номер_компьютера
GROUP BY k.Номер_компьютера, k.Имя_компьютера, p.Название_помещения;
GO

SELECT * FROM Компьютеры_для_обслуживания
ORDER BY 
    CASE Приоритет_обслуживания
        WHEN 'ВЫСОКИЙ' THEN 1
        WHEN 'СРЕДНИЙ' THEN 2
        WHEN 'НИЗКИЙ' THEN 3
    END,
    Номер_компьютера;

SELECT * FROM Компьютеры_для_обслуживания
WHERE Приоритет_обслуживания = 'ВЫСОКИЙ';

