
**1. Какие цели могут быть достигнуты за счет использования программируемых объектов БД?**

Использование программируемых объектов базы данных позволяет достичь следующих целей:
1.  **Повышение производительности:** Хранимые процедуры и функции компилируются и кэшируются на сервере, что снижает сетевой трафик и ускоряет выполнение.
2.  **Инкапсуляция и модульность бизнес-логики:** Логика обработки данных выносится в базу данных, обеспечивая централизованное управление, повторное использование кода и единообразие правил.
3.  **Усиление безопасности:** Можно предоставлять права доступа не к таблицам напрямую, а к программируемым объектам (процедурам, представлениям), тем самым контролируя и валидируя все операции с данными. Это также один из способов защиты от SQL-инъекций.
4.  **Обеспечение целостности данных:** Триггеры позволяют автоматически выполнять проверки и действия при изменении данных, реализуя сложные ограничения целостности, которые нельзя описать с помощью `CHECK` или `FOREIGN KEY`.
5.  **Сокращение сетевого трафика:** Вместо отправки длинных запросов или пакетов операций клиент отправляет лишь вызов процедуры.

**2. Какими способами можно присвоить значение локальной переменной?**

В Transact-SQL (T-SQL) значение локальной переменной можно присвоить следующими способами:
1.  **С помощью оператора `SET`:** `SET @VariableName = Значение;`
2.  **С помощью оператора `SELECT`:** `SELECT @VariableName = Значение;` (часто используется для присвоения значения из результата подзапроса).
3.  **При объявлении (начиная с SQL Server 2008):** `DECLARE @VariableName DataType = Значение;`

**3. Каковы различия в области видимости табличной переменной, локальной и глобальной временных таблиц?**

*   **Табличная переменная (`@TableVar`):**
    *   **Область видимости:** Как и любая локальная переменная — доступна только в рамках пакета, процедуры или функции, где была объявлена. Невидима для вложенных процедур (если не передана как параметр).
    *   **Время жизни:** Существует только на время выполнения пакета, процедуры или функции.
    *   **Хранение:** Обычно хранится в оперативной памяти (tempdb), но при большом объеме данных может быть вытеснена на диск.
*   **Локальная временная таблица (`#TempTable`):**
    *   **Область видимости:** Видима только в рамках того же соединения (сессии), в котором была создана, и только в той области (процедура, пакет), где создана. Автоматически удаляется при закрытии области видимости (если создана в процедуре) или при разрыве соединения.
    *   **Хранение:** Всегда хранится в системной базе данных `tempdb`.
*   **Глобальная временная таблица (`##GlobalTempTable`):**
    *   **Область видимости:** Видима **всем соединениям** с сервером.
    *   **Время жизни:** Существует до тех пор, пока не будет явно удалена командой `DROP TABLE` или пока не завершится последнее соединение, которое её использует.
    *   **Хранение:** Всегда хранится в `tempdb`.

**4. Какие типы хранимых процедур вам известны?**

1.  **Пользовательские хранимые процедуры:** Основной тип, создаваемый разработчиками.
2.  **Системные хранимые процедуры:** Предопределённые процедуры (с префиксом `sp_`), поставляемые с SQL Server для администрирования и получения системной информации.
3.  **Временные хранимые процедуры:** Создаются с префиксом `#` (локальная) или `##` (глобальная) и хранятся в `tempdb`. Удаляются при закрытии соединения.
4.  **Расширенные хранимые процедуры (устаревшие):** Позволяли вызывать функции из DLL-библиотек (префикс `xp_`). Не рекомендуется к использованию.
5.  **CLR-хранимые процедуры:** Создаются с использованием .NET Framework CLR (Common Language Runtime), что позволяет писать процедуры на языках C#, VB.NET.

**5. Что такое SQL-инъекция?**

**SQL-инъекция (SQL Injection)** — это уязвимость системы безопасности веб-приложения или программы, которая позволяет злоумышленнику **внедрять и выполнять произвольный SQL-код** в базе данных. Это происходит, когда приложение некорректно обрабатывает пользовательский ввод, «склеивая» его с SQL-запросом без должной проверки и экранирования.

**6. Что такое триггер? Какие типы триггеров поддерживает SQL Server?**

**Триггер (Trigger)** — это специальный тип хранимой процедуры, который **автоматически выполняется** в ответ на определённое событие в базе данных.

SQL Server поддерживает следующие основные типы триггеров:
1.  **DML-триггеры (Data Manipulation Language):** Срабатывают при событиях изменения данных: `INSERT`, `UPDATE`, `DELETE`.
    *   `AFTER TRIGGER` (или `FOR TRIGGER`): Срабатывает **после** завершения операции.
    *   `INSTEAD OF TRIGGER`: Срабатывает **вместо** выполнения операции.
2.  **DDL-триггеры (Data Definition Language):** Срабатывают при событиях изменения структуры базы данных или сервера: `CREATE`, `ALTER`, `DROP` (например, для таблиц, процедур).
3.  **LOGON-триггеры:** Срабатывают при событии входа пользователя в систему (LOGON).

**7. Какие служебные таблицы предоставляет DML-триггерам SQL Server? Что в них содержится?**

DML-триггеры имеют доступ к специальным псевдотаблицам, которые существуют только во время выполнения триггера:
*   **`INSERTED`:** Содержит **новые** версии строк.
    *   Для операции `INSERT` — содержит все вставленные строки.
    *   Для операции `UPDATE` — содержит новые значения (после изменения) для всех обновлённых строк.
*   **`DELETED`:** Содержит **старые** версии строк.
    *   Для операции `DELETE` — содержит все удалённые строки.
    *   Для операции `UPDATE` — содержит старые значения (до изменения) для всех обновлённых строк.

**8. В чем особенности использования курсоров? Каковы основные типы серверных курсоров, поддерживаемых SQL Server?**

**Особенности (и недостатки) курсоров:**
*   **Последовательная обработка:** Позволяют обрабатывать результирующий набор построчно, в отличие от стандартных операций над множествами (set-based).
*   **Высокая ресурсоёмкость:** Используют больше ресурсов (памяти, блокировок), чем операции над множествами.
*   **Медленная скорость:** Обычно работают медленнее, чем эквивалентные запросы, основанные на множествах.
*   **Область применения:** Следует использовать только тогда, когда операцию **невозможно** выразить одним запросом (например, сложная последовательная бизнес-логика для каждой строки).

**Основные типы серверных курсоров в SQL Server:**
1.  **Статические (Static / Insensitive):** Создаёт статическую копию данных в `tempdb`. Не отражает изменения, произошедшие в исходных данных после открытия курсора.
2.  **Динамические (Dynamic):** Отражает все изменения, происходящие в строках результирующего набора, включая новые строки, удовлетворяющие условию. Самый ресурсоёмкий.
3.  **Набор ключей (Keyset-Driven):** Хранит в `tempdb` только уникальные идентификаторы (ключи) выбранных строк. Отражает обновления и удаления строк, но не отражает вставку новых строк, которые удовлетворяют условию выборки.
4.  **Быстрые последовательные (Fast-Forward / Forward-Only):** Упрощённый, оптимизированный курсор, который можно перемещать только вперёд. Часто является наиболее эффективным, если требуется только однопроходная обработка.

**9. В чем особенности индексированных представлений?**

**Индексированное представление (Materialized View)** — это представление, для которого создан **уникальный кластеризованный индекс** (а также могут быть созданы некластеризованные). Его особенности:
1.  **Материализация данных:** Данные представления физически сохраняются в базе данных (в индексе), а не вычисляются на лету при каждом обращении.
2.  **Значительное повышение производительности:** Для сложных запросов с агрегацией, соединениями — выполнение происходит мгновенно за счёт чтения готовых данных из индекса.
3.  **Синхронизация данных:** SQL Server автоматически поддерживает актуальность материализованных данных при изменении базовых таблиц, что влечёт накладные расходы на операции `INSERT/UPDATE/DELETE`.
4.  **Строгие ограничения:** Для создания индексированного представления накладываются серьёзные синтаксические ограничения (например, нельзя использовать `OUTER JOIN` к более чем одной таблице, `DISTINCT`, определенные агрегатные функции без `COUNT_BIG` и др.).
5.  **Требует настройки:** Для использования оптимизатором запросов часто требуется установить параметр `SET QUERY_OPTIMIZER_HINTS` или использовать `NOEXPAND` в Enterprise Edition.


