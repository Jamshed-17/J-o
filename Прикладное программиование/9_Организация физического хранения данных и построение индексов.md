**1. Объясните разницу между таблицей с кластеризованным индексом и без него (так называемой кучей).**

*   **Куча (Table without a Clustered Index):** Это таблица, данные которой физически хранятся в произвольном (несортированном) порядке. Новые строки добавляются в любое свободное место в таблице (часто в конец). Структура данных — неупорядоченный набор страниц данных. Поиск по такой таблице требует полного сканирования (Table Scan), что медленно для больших таблиц.
*   **Таблица с кластеризованным индексом (Clustered Index):** Кластеризованный индекс определяет **физический порядок хранения данных** в таблице. Сами данные (строки) на диске сортируются по значениям ключа индекса. Поэтому таблица может иметь только один кластеризованный индекс. Он подобен алфавитному указателю в книге, где сами страницы уже идут в алфавитном порядке. Поиск по ключу кластеризованного индекса очень эффективен.

**2. В чем отличие в организации кластеризованного и некластеризованного индексов в СУБД SQL Server?**

*   **Кластеризованный индекс** — это **и есть сама таблица**, упорядоченная по ключу индекса. Листовой уровень (leaf level) индекса содержит сами строки данных.
*   **Некластеризованный индекс** — это отдельная структура данных, которая хранит **копию ключевых столбцов индекса**, отсортированную по ним, и **указатель (ссылку)** на соответствующую строку данных в таблице. Если таблица имеет кластеризованный индекс, то указателем является значение ключа кластеризованного индекса. Если таблица — куча, то указателем является идентификатор физической строки (RID).

**3. Как SQL Server хранит данные индексов?**

SQL Server хранит данные индексов в виде **сбалансированных деревьев (B-деревьев)**. Дерево состоит из корневого уровня (root level), одного или нескольких промежуточных уровней (intermediate levels) и конечного (листового) уровня (leaf level).
*   **Листовой уровень кластеризованного индекса** содержит сами страницы данных таблицы.
*   **Листовой уровень некластеризованного индекса** содержит ключевые столбцы индекса и указатель на соответствующую строку данных.
*   **Промежуточные и корневой уровни** содержат так называемые индексные страницы, которые хранят диапазоны ключей и указатели на страницы следующего уровня дерева.

**4. Какой индекс называется покрывающим?**

**Покрывающий индекс (Covering Index)** — это некластеризованный индекс, в листовых узлах которого содержатся **все столбцы, необходимые для выполнения конкретного запроса**. Это позволяет оптимизатору выполнить запрос, обращаясь только к индексу, без дополнительного обращения к основной таблице (так называемая операция Index Seek или Index Scan), что значительно ускоряет выполнение.

**5. Поясните, как наличие индексов влияет на план выполнения запроса?**

Наличие индексов напрямую влияет на **выбор оптимального пути доступа к данным**, который делает оптимизатор запросов. Индексы позволяют:
*   **Исключить полное сканирование таблицы (Table Scan)** за счёт поиска по индексу (Index Seek).
*   **Ускорить операции соединения (JOIN)**, сортировки (ORDER BY) и группировки (GROUP BY), если индексы созданы на соединяемых или сортируемых столбцах.
*   **Предоставить покрывающий индекс**, исключая дополнительные операции поиска в таблице (Key Lookup/RID Lookup).
Оптимизатор анализирует доступные индексы, статистику и выбирает план с наименьшей предполагаемой стоимостью (по времени и ресурсам).

**6. При выполнении каких операций наличие у таблицы нескольких индексов приводит к дополнительным затратам времени?**

Наличие множества индексов замедляет операции **модификации данных**:
*   **Вставка (INSERT):** Каждый новый индекс должен быть обновлён (в него должна быть добавлена новая запись).
*   **Обновление (UPDATE):** Если обновляются столбцы, входящие в ключ индекса, индексная запись должна быть перемещена (перестроена).
*   **Удаление (DELETE):** Запись должна быть удалена из всех индексов.
Таким образом, чем больше индексов, тем больше накладных расходов на поддержание их актуальности при изменении данных.

**7. Опишите основные характеристики и параметры индекса, которые можно указать при его создании.**

При создании индекса можно указать:
*   **Имя индекса**.
*   **Тип индекса**: `CLUSTERED` (кластеризованный) или `NONCLUSTERED` (некластеризованный), `UNIQUE` (уникальный).
*   **Ключевые столбцы**: столбцы, по которым строится индекс, с указанием порядка сортировки (`ASC` или `DESC`).
*   **Включенные столбцы (INCLUDE)**: неключевые столбцы, которые добавляются на листовой уровень индекса для создания покрывающего индекса.
*   **Параметры хранения**: `FILLFACTOR` (процент заполнения страниц), `PAD_INDEX`, `SORT_IN_TEMPDB` и др.
*   **Параметры обработки блокировок и параллелизма**: `ALLOW_ROW_LOCKS`, `ALLOW_PAGE_LOCKS`, `MAXDOP`.

**8. В чем особенность использования в индексе включенных столбцов?**

**Включённые столбцы (INCLUDED columns)** добавляются на **листовой уровень некластеризованного индекса**, но **не являются частью ключа индекса**. Они:
*   **Не влияют на порядок сортировки** данных в индексе.
*   **Не учитываются при ограничении на размер ключа индекса** (900 байт для старых версий, 1700 байт для новых). На них распространяется лимит общего размера строки индекса.
*   Их основная цель — создание **покрывающего индекса** без увеличения размера ключа и без нарушения лимита на его размер.

**9. Предложите покрывающий индекс для запроса `SELECT DISTINCT Title, Author FROM Book1`. Напишите команду, создающую предложенный индекс.**

Для этого запроса необходим некластеризованный индекс, покрывающий столбцы `Title` и `Author`. Чтобы операция `DISTINCT` также могла эффективно выполняться с помощью индекса (без сортировки всей таблицы), имеет смысл сделать ключевым столбцом `Title` (или оба), а `Author` — включённым столбцом. Однако, для эффективного устранения дубликатов на этапе Index Scan, можно включить оба столбца в ключ.

**Вариант 1 (оба столбца в ключе, подходит для фильтрации/сортировки по любому из них):**
```sql
CREATE NONCLUSTERED INDEX IX_Book1_Title_Author
ON Book1 (Title, Author);
```

**Вариант 2 (один столбец в ключе, второй включённый, если есть ограничения на размер ключа):**
```sql
CREATE NONCLUSTERED INDEX IX_Book1_Title_Include_Author
ON Book1 (Title)
INCLUDE (Author);
```

Оба индекса являются **покрывающими** для данного запроса, так как содержат в своей структуре все необходимые столбцы (`Title` и `Author`).
